# C# + MaxScript
С помощью C# формируем MaxScript и визуализируем данные в 3DS Max
<h2>Содержание</h2>
<ul>
  <li><a href="#task">Задача;</a></li>
  <li><a href="#theory">Немного теории об алгоритме компоновки;</a></li>
  <li><a href="#sharp">Код С#;</a></li>
  <li><a href="#max">Код MaxScript;</a></li>
  <li><a href="#result">Результат работы.</a></li>
</ul>

<h2 id="task">Задача</h2>
<p align="justify">
Поставлена задача применить алгоритм компоновки печатной платы. Сам алгоритм применить не сложно, он последовательный, что упрощает процесс кодирования.
</p>

<p align="justify">
На вход программе подается некоторый NET-файл, который представляет из себя текстовый файл. В нем хранится названия элементов печатной платы; и какой номер пина элемента подключен к той или иной цепи.
</p>

<p align="justify">
В данной программе используется последовательный алгоритм копмпоновки с применением матрицы цепей. Исходя из данных NET-файла строится матрица цепей. И на ее основе реализуется алгоритм компоновки. Далее следует визуализировать результат применения алгоритма компоновки.
</p>

<p align="justify">
Но возникает вопрос: "А как визуализировать результат компоновки?". Так как стоит задача только компоновки элементов, а не трассировки, то визуализировать компоновку без трассировки в 2D пространстве затруднительно.
</p>

<p align="justify">
Но что мешает визуализировать в 3D?
</p>

<h2 id="theory">Немного теории об алгоритме компоновки</h2>

<p align="justify">
Принципиальные электрические схемы соединения многоконтактных элементов (например, микросхем и микросборок) удобно представлять гиперграфом Q и записывать в виде матрицы цепей:
</p>

<p>
<img src="https://img-fotki.yandex.ru/get/477464/49342033.0/0_23bb14_3fa750ed_orig.png" width="172" height="46" border="0" title="1.PNG" alt="1.PNG"/>
</p>

<p align="justify">
где m — число элементов схемы; k — число выводов многоконтакт-ных элементов.
</p>

<p align="justify">
Элемент Сij матрицы С означает номер электрической цепи, которая подключается к j-му выводу i-го многоконтактного элемента. Если контакт свободен, то Сij = 0. Оптимальному разбиению схемы на n частей G1, G2. …, Gn соответствует такое разбиение матрицы С на подматрицы С1. С2. .... Сn, при котором число связей между частями минимально. Критерий оптимальности в этом случае записывается в виде:
</p>

<p>
<img src="https://img-fotki.yandex.ru/get/772910/49342033.0/0_23bb15_901896b1_orig.png" width="489" height="78" border="0" title="2.PNG" alt="2.PNG"/>
</p>

<p>
где Rij — число связей между i-й и j-й частями.
</p>

<p align="justify">
Работа алгоритма заключается в поочередном определении для каждого элемента Ui схемы чисел ∆R<sub>1</sub><sup>i</sup>, ∆R<sub>2</sub><sup>i</sup>…∆R<sub>n</sub><sup>i</sup>, характе¬ризующих приращение связей при расположении этого элемента в части G1, G2…Gn. Для определения этих чисел вводится вспо¬могательная матрица W = || wij ||<sub>n x l</sub>
</p>
<p>
где l — число цепей схемы; n — число частей разбиения.
</p>

<p>
Элемент матрицы Wij определяется соотношением:
</p>

<p>
<img src="https://img-fotki.yandex.ru/get/962386/49342033.0/0_23bb16_f0688493_orig.png" width="541" height="67" border="0" title="3.PNG" alt="3.PNG"/>
</p>

<p align="justify">
Число ∆R<sub>j</sub><sup>i</sup> равно числу единиц l-вектора строки W<sub>j</sub><sup>i</sup>, рассчитываемой во формуле:
</p>

<p>
<img src="https://img-fotki.yandex.ru/get/962386/49342033.0/0_23bb17_6a041f4_orig.png" width="323" height="129" border="0" title="4.PNG" alt="4.PNG"/>
</p>

<p align="justify">
где W<sup>v</sup> – v-я строка матрицы W; "не" Wj - это инверсия строки Wj; W<sup>0</sup><sub>i</sub>- l-вектор-строка, заполненная в соответствии с предыдущей формулой.
</p>

<p align="justify">
Из чисел ∆R<sub>1</sub><sup>i</sup>, ∆R<sub>2</sub><sup>i</sup>…∆R<sub>n</sub><sup>i</sup> выбирается минимальное, и элемент Ui заносится в соответствующую часть.
</p>

<h2 id="sharp">Код C#</h2>

<p align="justify">
Программа реализована на основе WPF. В идеале стоило применить какой-нибудь паттерн, который разделяет представление (View) и модель (Model), но логику данного кода не сложно "подогнать", допустим, в консольную версию программы.
</p>
